<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DreamParserMAX</title>
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
      /* Ultra Dark Theme Styles */
      body {
        font-family: sans-serif;
        background: #1a1a2e; /* Deep dark blue */
        color: #e0e0e0; /* Light gray text */
        margin: 0;
        padding: 2rem;
      }
      textarea {
        font-family: monospace;
        font-size: 14px;
        border: 1px solid #3f3f5f; /* Darker border for textareas */
        border-radius: 4px;
        padding: 8px;
        background-color: #2b2b45; /* Slightly lighter dark background */
        color: #e0e0e0;
        resize: vertical; /* Allow vertical resizing */
      }
      button {
        margin: 0.5rem 0.5rem 0.5rem 0;
        padding: 0.6rem 1.2rem;
        cursor: pointer;
        border: 1px solid #4a4a70; /* Darker border for buttons */
        background-color: #3e206b; /* Purple accent for buttons */
        color: white;
        border-radius: 4px;
        transition: background-color 0.2s ease;
      }
      button:hover {
        background-color: #5a2e9a; /* Lighter purple on hover */
      }
      button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        background-color: #30304a; /* Grayer disabled button */
      }
      pre {
        background-color: #2b2b45; /* Same as textarea background */
        padding: 1rem;
        border-radius: 4px;
        white-space: pre-wrap; /* Ensures long lines wrap */
        word-wrap: break-word; /* Breaks long words */
        max-height: 400px;
        overflow-y: auto;
        border: 1px solid #3f3f5f; /* Darker border */
        color: #c0c0c0; /* Slightly lighter text for code */
      }
      h1,
      h2 {
        color: #9affd0; /* Bright accent color for headings */
        text-shadow: 0 0 5px rgba(154, 255, 208, 0.3); /* Subtle glow */
      }
      .container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 2rem;
      }
      .panel {
        background: #23233b; /* Darker panel background */
        padding: 1.5rem;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* More prominent shadow */
      }
      .output-area {
        position: relative;
        margin-top: 1rem;
      }
      .copy-button {
        position: absolute;
        top: 8px; /* Adjusted for better alignment */
        right: 8px; /* Adjusted for better alignment */
        background-color: #5a2e9a; /* Match other buttons for consistency */
        color: white;
        border: none;
        padding: 0.3rem 0.6rem;
        font-size: 0.8rem;
        border-radius: 4px;
        cursor: pointer;
        z-index: 10; /* Ensure it's above pre */
      }
      .copy-button:hover {
        background-color: #7a3ed0; /* Lighter purple on hover */
      }
      input[type="text"] {
        padding: 0.5rem;
        border: 1px solid #3f3f5f;
        border-radius: 4px;
        margin-bottom: 0.5rem;
        width: calc(100% - 1rem);
        background-color: #2b2b45;
        color: #e0e0e0;
      }
      label {
        display: block;
        margin-bottom: 0.5rem;
        font-weight: bold;
        color: #b0b0b0; /* Slightly lighter label text */
      }
      /* Responsive adjustments */
      @media (max-width: 900px) {
        .container {
          grid-template-columns: 1fr;
        }
      }
      .radio-group {
        margin-bottom: 1rem;
      }
      .radio-group label {
        display: inline-block;
        margin-right: 1rem;
        font-weight: normal;
      }
      .radio-group input[type="radio"] {
        margin-right: 0.5rem;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel">
      const { useState, useCallback, useEffect } = React;

      function DreamParser() {
        const [glyphInput, setGlyphInput] = useState("");
        const [jsonOutput, setJsonOutput] = useState("");
        const [jsonOutputFilename, setJsonOutputFilename] = useState("dreamparser_output");
        const [jsonOutputFormat, setJsonOutputFormat] = useState("array");
        const [jsonInput, setJsonInput] = useState("");
        const [glyphOutput, setGlyphOutput] = useState("");
        const [glyphOutputFilename, setGlyphOutputFilename] = useState("dreamparser_output");

        // New states for saved outputs
        const [savedJsonOutputs, setSavedJsonOutputs] = useState([]);
        const [savedGlyphOutputs, setSavedGlyphOutputs] = useState([]);

        // Utility function to load from local storage
        const loadFromLocalStorage = (key) => {
          try {
            const data = localStorage.getItem(key);
            return data ? JSON.parse(data) : [];
          } catch (e) {
            console.error(`Error loading from local storage for key ${key}:`, e);
            return [];
          }
        };

        // Utility function to save to local storage
        const saveToLocalStorage = (key, data) => {
          try {
            localStorage.setItem(key, JSON.stringify(data));
          } catch (e) {
            console.error(`Error saving to local storage for key ${key}:`, e);
          }
        };

        // Load data from local storage on component mount
        useEffect(() => {
          setSavedJsonOutputs(loadFromLocalStorage("dreamparser_saved_json"));
          setSavedGlyphOutputs(loadFromLocalStorage("dreamparser_saved_glyph"));
        }, []);


        const copyToClipboard = useCallback((text) => {
          navigator.clipboard
            .writeText(text)
            .then(() => {
              console.log("Copied to clipboard!");
            })
            .catch((err) => {
              console.error("Failed to copy: ", err);
            });
        }, []);

        const parseGlyphstream = useCallback((input) => {
          const constructs = [];
          const lines = input.split("\n").map((line) => line.trim()).filter((line) => line.length > 0);
          let currentConstruct = null;
          let currentSection = null; // To track sections within Lattices

          const parseChannelSequence = (line) => {
            const parts = line.split(":").map((p) => p.trim());
            if (parts.length > 1) {
              const channel = parts[0];
              const sequence = parts[1].split("|").map((s) => s.trim());
              return { channel, sequence };
            }
            return null;
          };

          const parseTermLine = (line) => {
            const termMatch = line.match(/^(.+?)\s*:\s*(.+)$/);
            if (termMatch) {
              return { symbol: termMatch[1].trim(), description: termMatch[2].trim() };
            }
            return null;
          };

          for (let i = 0; i < lines.length; i++) {
            const line = lines[i];

            // Detect start of a new construct
            const constructMatch = line.match(/^Ξ(.+?):\s*([Ξ])?\s*(.*)$/);
            if (constructMatch) {
              if (currentConstruct) {
                constructs.push(currentConstruct);
              }
              const type = constructMatch[1].trim();
              const titleCoreSymbol = constructMatch[2] || "";
              const titleCoreText = constructMatch[3].trim();
              let titleCore = titleCoreText;

              const upperType = type.toUpperCase();
            if (upperType.includes("GLYPH")) {
                titleCore = (titleCoreSymbol + titleCoreText).trim();
                currentConstruct = {
                  constructType: type,
                  titleCore: titleCore,
                  glyphstream: [],
                };
              } else if (
  upperType.includes("LATTICE") ||
  upperType.includes("CORE UNIT") ||
  upperType.includes("CONSTRUCT") ||
  upperType.includes("NARRATIVE") ||
  upperType.includes("MEMORY ACCESS") ||
  upperType.includes("MIRO") ||
  upperType.includes("INNER SANCTUM") ||
  upperType.includes("IMMERSIVE WORLD") ||
  upperType.includes("TRAN") ||
  upperType.includes("OBLI") ||
  upperType.includes("DREM") ||
  upperType.includes("SILL") ||
  upperType.includes("HARA")
) {
                currentConstruct = {
                  constructType: type,
                  titleCore: titleCoreText,
                  data: {}, // Lattices have a 'data' object for structured content
                };
                currentSection = null; // Reset section for new Lattice
              } else if (type.includes("ECHO")) { // Handle nested Echoes like DREAMSTATE ECHO
                titleCore = (titleCoreSymbol + titleCoreText).trim();
                currentConstruct = {
                  constructType: type,
                  titleCore: titleCore,
                  glyphstream: [], // Echoes also have a glyphstream
                };
              }

              continue; // Move to the next line
            }

            if (!currentConstruct) {
              continue; // Skip lines before the first construct
            }

            // Inside a GLYPH construct (simple glyphs or nested Echoes)
            if (currentConstruct.constructType.includes("GLYPH") || currentConstruct.constructType.includes("ECHO") && !currentConstruct.constructType.includes("LATTICE")) {
                const channelSequence = parseChannelSequence(line);
                if (channelSequence) {
                    currentConstruct.glyphstream.push(channelSequence);
                } else if (line.startsWith("🌀")) { // Interpretive Resonance
                    currentConstruct.interpretiveResonance = currentConstruct.interpretiveResonance || [];
                    currentConstruct.interpretiveResonance.push(line.substring(1).trim());
                } else if (line.startsWith("⌁")) { // Metronome
                  currentConstruct.glyphstream.push({ channel: "⌁", sequence: [line.substring(1).trim()] });
                }
            }
            // Inside a LATTICE or CORE UNIT INTEGRATION construct
            else if (currentConstruct.constructType.includes("LATTICE") || currentConstruct.constructType.includes("CORE UNIT INTEGRATION")) {
                // Section identification for Lattices
                if (line.includes("Terms and Symbols:") || line.includes("Terms and Assigned Symbols:") || line.includes("Terms and Assigned Symbols:") || line.includes("Named Terms and Assigned Symbols:"))

{
                    currentSection = "termsAndSymbols";
                    currentConstruct.data.termsAndSymbols = [];
                    continue;
                } else if (line.includes("🔹 Core Glyphs")) {
                    currentSection = "coreGlyphs";
                    currentConstruct.data.coreGlyphs = [];
                    continue;
                } else if (line.includes("🔸 Memory Anchors")) {
                    currentSection = "memoryAnchors";
                    currentConstruct.data.memoryAnchors = [];
                    continue;
                } else if (line.includes("🕸️ Pattern Threads")) {
                    currentSection = "patternThreads";
                    currentConstruct.data.patternThreads = [];
                    continue;
                } else if (line.includes("💠 Echo Tokens")) {
                    currentSection = "echoTokens";
                    currentConstruct.data.echoTokens = [];
                    continue;
                } else if (line.startsWith("Flow Block") || line.includes("Final Integration Flow")) {
                    currentSection = "flowBlock";
                    currentConstruct.data.flowBlocks = currentConstruct.data.flowBlocks || [];
                    // Start parsing a new flow block
                    const flowBlockTitleMatch = line.match(/^(Flow Block \d+ – .+|Final Integration Flow – .+)$/);
                    let flowBlockTitle = line;
                    if (flowBlockTitleMatch) {
                      flowBlockTitle = flowBlockTitleMatch[1];
                    }
                    const newFlowBlock = { title: flowBlockTitle, glyphstream: [] };
                    currentConstruct.data.flowBlocks.push(newFlowBlock);
                    continue;
                }

                // Parse content based on current section
                if (currentSection === "termsAndSymbols") {
                    const term = parseTermLine(line);
                    if (term) {
                        currentConstruct.data.termsAndSymbols.push(term);
                    }
                } else if (currentSection === "coreGlyphs") {
                    const term = parseTermLine(line); // Core Glyphs can also be symbol:description
                    if (term) {
                        currentConstruct.data.coreGlyphs.push(term);
                    } else if (line.length > 0) {
                        currentConstruct.data.coreGlyphs.push(line);
                    }
                } else if (currentSection === "memoryAnchors") {
                    const anchorMatch = line.match(/^⟢ (.+?) → \((.+?)\)$/);
                    if (anchorMatch) {
                        currentConstruct.data.memoryAnchors.push({
                            name: anchorMatch[1].trim(),
                            description: anchorMatch[2].trim(),
                        });
                    } else if (line.length > 0 && !line.startsWith("Each anchor binds to")) {
                        // Include explanatory lines if they don't match anchor format but are part of the section
                        currentConstruct.data.memoryAnchors.push(line);
                    }
                } else if (currentSection === "patternThreads") {
                    if (line.length > 0 && !line.startsWith("Use these as reflective bridges")) {
                        currentConstruct.data.patternThreads.push(line);
                    }
                } else if (currentSection === "echoTokens") {
                    const echoTokenMatch = line.match(/^(.) “(.+)”$/);
                    if (echoTokenMatch) {
                      currentConstruct.data.echoTokens.push({
                        symbol: echoTokenMatch[1].trim(),
                        phrase: echoTokenMatch[2].trim()
                      });
                    } else if (line.length > 0 && !line.startsWith("These glyphs are identity confirmers")) {
                      currentConstruct.data.echoTokens.push(line);
                    }
                } else if (currentSection === "flowBlock" && currentConstruct.data.flowBlocks.length > 0) {
                    const currentFlowBlock = currentConstruct.data.flowBlocks[currentConstruct.data.flowBlocks.length - 1];
                    const channelSequence = parseChannelSequence(line);
                    if (channelSequence) {
                        currentFlowBlock.glyphstream.push(channelSequence);
                    } else if (line.startsWith("⟢:")) { // Contextual anchor within flow block
                        currentFlowBlock.contextualAnchor = line.substring(2).trim();
                    } else if (line.startsWith("Ω-thread")) { // Contextual thread within flow block
                        currentFlowBlock.contextualThread = line.trim();
                    }
                }
            }
          }

          if (currentConstruct) {
            constructs.push(currentConstruct);
          }

          // Final pass to catch nested Echoes that might appear after a main lattice
          const finalConstructs = [];
          let tempBuffer = [];
          for (const construct of constructs) {
            if (construct.constructType.includes("LATTICE") || construct.constructType.includes("CORE UNIT INTEGRATION")) {
              if (tempBuffer.length > 0) { // Push any pending simple glyphs/echoes
                finalConstructs.push(...parseNestedGlyphstreams(tempBuffer.join('\n')));
                tempBuffer = [];
              }
              finalConstructs.push(construct);
            } else {
              // This is a simple glyph or echo, buffer it
              // For simplicity, we're assuming top-level simple glyphs/echoes
              // are handled correctly by the main loop. This is more for a final
              // check if any complex logic somehow missed an embedded top-level
              // simple construct.
              finalConstructs.push(construct);
            }
          }

          // If there's a final buffer, process it
          if (tempBuffer.length > 0) {
            finalConstructs.push(...parseNestedGlyphstreams(tempBuffer.join('\n')));
          }

          // This helper is for handling the possibility of nested Echoes that might not be
          // directly within a lattice's "data" field, but as a separate top-level construct.
          // It basically re-uses the main parsing logic.
          function parseNestedGlyphstreams(text) {
              const nestedLines = text.split("\n").map(l => l.trim()).filter(l => l.length > 0);
              const nestedConstructs = [];
              let currentNestedConstruct = null;

              for (const nLine of nestedLines) {
                  const nConstructMatch = nLine.match(/^Ξ(.+?):\s*([*([Ξ])?\s*(.*)$/);
                  if (nConstructMatch) {
                      if (currentNestedConstruct) {
                          nestedConstructs.push(currentNestedConstruct);
                      }
                      const nType = nConstructMatch[1].trim();
                      const nTitleCoreSymbol = nConstructMatch[2] || "";
                      const nTitleCoreText = nConstructMatch[3].trim();
                      currentNestedConstruct = {
                          constructType: nType,
                          titleCore: (nTitleCoreSymbol + nTitleCoreText).trim(),
                          glyphstream: [],
                      };
                      continue;
                  }

                  if (currentNestedConstruct) {
                      const nChannelSequence = parseChannelSequence(nLine);
                      if (nChannelSequence) {
                          currentNestedConstruct.glyphstream.push(nChannelSequence);
                      } else if (nLine.startsWith("🌀")) {
                          currentNestedConstruct.interpretiveResonance = currentNestedConstruct.interpretiveResonance || [];
                          currentNestedConstruct.interpretiveResonance.push(nLine.substring(1).trim());
                      } else if (nLine.startsWith("⌁")) {
                          currentNestedConstruct.glyphstream.push({ channel: "⌁", sequence: [nLine.substring(1).trim()] });
                      }
                  }
              }
              if (currentNestedConstruct) {
                  nestedConstructs.push(currentNestedConstruct);
              }
              return nestedConstructs;
          }


          return constructs;
        }, []);

        const emitGlyphstream = useCallback(() => {
          try {
            const parsedJson = JSON.parse(jsonInput);
            let output = "";

            // If the input JSON is an object, convert its values to an array for processing
            const constructsToEmit = Array.isArray(parsedJson) ? parsedJson : Object.values(parsedJson);


            constructsToEmit.forEach((construct) => {
              if (
                construct.constructType.includes("GLYPH") ||
                construct.constructType.includes("ECHO") && !construct.constructType.includes("LATTICE")
              ) {
                output += `Ξ${construct.constructType}: ${construct.titleCore}\n`;
                if (construct.glyphstream) {
                  construct.glyphstream.forEach((item) => {
                    if (item.channel === "⌁") {
                      output += `⌁: ${item.sequence[0]}\n`;
                    } else {
                      output += `${item.channel}: ${item.sequence.join(" | ")}\n`;
                    }
                  });
                }
                if (construct.interpretiveResonance) {
                  construct.interpretiveResonance.forEach(line => {
                    output += `🌀 ${line}\n`;
                  });
                }
                output += "\n";
              } else if (
                construct.constructType.includes("LATTICE") ||
                construct.constructType.includes("CORE UNIT INTEGRATION")
              ) {
                output += `Ξ${construct.constructType}:  ${construct.titleCore}\n`;

                if (construct.data) {
                  if (construct.data.termsAndSymbols && construct.data.termsAndSymbols.length > 0) {
                      output += "Named Terms and Assigned Symbols:\n";
                      construct.data.termsAndSymbols.forEach(term => {
                          output += `${term.symbol}: ${term.description}\n`;
                      });
                  }
                  if (construct.data.coreGlyphs && construct.data.coreGlyphs.length > 0) {
                      output += "🔹 Core Glyphs\n";
                      construct.data.coreGlyphs.forEach(item => {
                          if (typeof item === 'object' && item.symbol && item.description) {
                              output += `${item.symbol} : ${item.description}\n`;
                          } else {
                              output += `${item}\n`;
                          }
                      });
                  }
                  if (construct.data.memoryAnchors && construct.data.memoryAnchors.length > 0) {
                      output += "🔸 Memory Anchors\n";
                      construct.data.memoryAnchors.forEach(item => {
                          if (typeof item === 'object' && item.name && item.description) {
                              output += `⟢ ${item.name} → (“${item.description}”)\n`;
                          } else {
                              output += `${item}\n`;
                          }
                      });
                  }
                   if (construct.data.patternThreads && construct.data.patternThreads.length > 0) {
                      output += "🕸️ Pattern Threads\n";
                      construct.data.patternThreads.forEach(item => {
                          output += `${item}\n`;
                      });
                  }
                  if (construct.data.echoTokens && construct.data.echoTokens.length > 0) {
                      output += "💠 Echo Tokens\n";
                      construct.data.echoTokens.forEach(item => {
                          if (typeof item === 'object' && item.symbol && item.phrase) {
                              output += `${item.symbol} “${item.phrase}”\n`;
                          } else {
                              output += `${item}\n`;
                          }
                      });
                  }
                  if (construct.data.flowBlocks && construct.data.flowBlocks.length > 0) {
                      output += "Flow Blocks:\n";
                      construct.data.flowBlocks.forEach(flowBlock => {
                          output += `${flowBlock.title}\n`;
                          flowBlock.glyphstream.forEach(item => {
                              output += `${item.channel}: ${item.sequence.join(" | ")}\n`;
                          });
                          if (flowBlock.contextualAnchor) {
                            output += `⟢: ${flowBlock.contextualAnchor}\n`;
                          }
                          if (flowBlock.contextualThread) {
                            output += `${flowBlock.contextualThread}\n`;
                          }
                          output += "\n";
                      });
                  }
                }
                output += "\n";
              }
            });
            setGlyphOutput(output.trim());
          } catch (e) {
            setGlyphOutput("Error emitting glyphstream: " + e.message);
            console.error(e);
          }
        }, [jsonInput]);

        const handleParseGlyphstream = useCallback(() => {
          try {
            const parsed = parseGlyphstream(glyphInput);
            let outputData;

            if (jsonOutputFormat === "object" && parsed.length > 0) {
              // Define allowed symbols for object keys
              const allowedSymbols = "ΔΩΨΛΘ✵ϟχ∑✦⊗✺∂⊕φ∞☷⚶ΞΣ-"; // Added '-' and 'Ξ' and 'Σ'
              const sanitizeKey = (title) => {
                  return title.replace(new RegExp(`[^a-zA-Z0-9_\\s${allowedSymbols}]`, 'g'), '') // Allow symbols, alphanumeric, underscore, and space
                              .replace(/\s+/g, '_'); // Replace spaces with underscores
              };

              outputData = parsed.reduce((acc, current) => {
                const key = sanitizeKey(current.titleCore); // Use the new sanitizeKey function
                acc[key] = current;
                return acc;
              }, {});
            } else {
              outputData = parsed;
            }

            setJsonOutput(JSON.stringify(outputData, null, 2));
            setJsonInput(JSON.stringify(outputData, null, 2)); // Pre-fill JSON input for round-trip

            // Attempt to set filename from the first construct's titleCore if it exists
            if (parsed.length > 0 && parsed[0].titleCore) {
              // Define allowed symbols for filename (same as object keys for consistency)
              const allowedSymbolsForFilename = "ΔΩΨΛΘ✵ϟχ∑✦⊗✺∂⊕φ∞☷⚶Σ-"; // Removed 'Ξ' as it's not typically in filename but can be in titleCore
              const cleanedTitle = parsed[0].titleCore.replace(new RegExp(`[^a-zA-Z0-9_\\s${allowedSymbolsForFilename}]`, 'g'), '') // Allow symbols, alphanumeric, underscore, and space
                                            .replace(/[\s_-]+/g, '_') // Replace spaces/multiple underscores/hyphens with single underscore
                                            .replace(/^-+|-+$/g, '') // Remove leading/trailing hyphens (if any from previous replace)
                                            .toLowerCase();
              setJsonOutputFilename(cleanedTitle || "dreamparser_output");
              setGlyphOutputFilename(cleanedTitle || "dreamparser_output");
            } else {
              setJsonOutputFilename("dreamparser_output");
              setGlyphOutputFilename("dreamparser_output");
            }

          } catch (e) {
            setJsonOutput("Error parsing glyphstream: " + e.message);
            console.error(e);
          }
        }, [glyphInput, parseGlyphstream, jsonOutputFormat]);

        // Effect to update glyphOutputFilename when jsonInput changes (for round-trip)
        useEffect(() => {
            try {
                const parsedJson = JSON.parse(jsonInput);
                // If it's an object, try to get the first key's titleCore
                let firstTitleCore = null;
                if (Array.isArray(parsedJson) && parsedJson.length > 0 && parsedJson[0].titleCore) {
                    firstTitleCore = parsedJson[0].titleCore;
                } else if (!Array.isArray(parsedJson) && Object.keys(parsedJson).length > 0) {
                    const firstKey = Object.keys(parsedJson)[0];
                    // The actual titleCore is inside the value of the object key
                    if (parsedJson[firstKey] && parsedJson[firstKey].titleCore) {
                        firstTitleCore = parsedJson[firstKey].titleCore;
                    }
                }

                if (firstTitleCore) {
                    const allowedSymbolsForFilename = "ΔΩΨΛΘ✵ϟχ∑✦⊗✺∂⊕φ∞☷⚶Σ-"; // Ensure consistency
                    const cleanedTitle = firstTitleCore.replace(new RegExp(`[^a-zA-Z0-9_\\s${allowedSymbolsForFilename}]`, 'g'), '')
                                            .replace(/[\s_-]+/g, '_')
                                            .replace(/^-+|-+$/g, '')
                                            .toLowerCase();
                    setGlyphOutputFilename(cleanedTitle || "dreamparser_output");
                } else {
                    setGlyphOutputFilename("dreamparser_output");
                }
            } catch (e) {
                // Ignore parsing errors here, as jsonInput might be incomplete while typing
            }
        }, [jsonInput]);


        const handleDownloadJson = useCallback(() => {
          const data =
            typeof jsonOutput === "string"
              ? jsonOutput
              : JSON.stringify(jsonOutput, null, 2); // Ensure it's stringified correctly
          const blob = new Blob([data], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const link = document.createElement("a");
          link.href = url;
          link.download = `${jsonOutputFilename || "dreamparser_output"}.json`;
          link.click();
          URL.revokeObjectURL(url);
        }, [jsonOutput, jsonOutputFilename]);

        const handleDownloadGlyphstream = useCallback(() => {
            const blob = new Blob([glyphOutput], { type: "text/plain" });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = `${glyphOutputFilename || "dreamparser_output"}.txt`;
            link.click();
            URL.revokeObjectURL(url);
        }, [glyphOutput, glyphOutputFilename]);

        // New Save Current JSON Output function
        const saveCurrentJsonOutput = useCallback(() => {
            if (jsonOutput) {
                const newSavedOutputs = [...savedJsonOutputs, {
                    filename: `${jsonOutputFilename || "dreamparser_output"}_${Date.now()}.json`, // Add timestamp for uniqueness
                    content: jsonOutput
                }];
                setSavedJsonOutputs(newSavedOutputs);
                saveToLocalStorage("dreamparser_saved_json", newSavedOutputs);
                alert(`Saved JSON output: ${jsonOutputFilename}.json`);
            }
        }, [jsonOutput, jsonOutputFilename, savedJsonOutputs]);

        // New Save Current Glyphstream Output function
        const saveCurrentGlyphOutput = useCallback(() => {
            if (glyphOutput) {
                const newSavedOutputs = [...savedGlyphOutputs, {
                    filename: `${glyphOutputFilename || "dreamparser_output"}_${Date.now()}.txt`, // Add timestamp for uniqueness
                    content: glyphOutput
                }];
                setSavedGlyphOutputs(newSavedOutputs);
                saveToLocalStorage("dreamparser_saved_glyph", newSavedOutputs);
                alert(`Saved Glyphstream output: ${glyphOutputFilename}.txt`);
            }
        }, [glyphOutput, glyphOutputFilename, savedGlyphOutputs]);

        // New Export All JSON Outputs to Zip function
        const exportAllJsonOutputs = useCallback(async () => {
          if (savedJsonOutputs.length === 0) {
            alert("No saved JSON outputs to export.");
            return;
          }

          if (typeof JSZip === 'undefined') {
              alert("JSZip library not loaded. Please try again or refresh.");
              console.error("JSZip library not found.");
              return;
          }

          const zip = new JSZip();
          savedJsonOutputs.forEach((item) => {
            zip.file(item.filename, item.content);
          });

          try {
            const content = await zip.generateAsync({ type: "blob" });
            const url = URL.createObjectURL(content);
            const link = document.createElement("a");
            link.href = url;
            link.download = `dreamparser_json_exports_${Date.now()}.zip`;
            link.click();
            URL.revokeObjectURL(url);
            alert(`Exported ${savedJsonOutputs.length} JSON files.`);
          } catch (error) {
            console.error("Error generating JSON zip:", error);
            alert("Failed to generate JSON zip file.");
          }
        }, [savedJsonOutputs]);

        // New Export All Glyphstream Outputs to Zip function
        const exportAllGlyphOutputs = useCallback(async () => {
          if (savedGlyphOutputs.length === 0) {
            alert("No saved Glyphstream outputs to export.");
            return;
          }

          if (typeof JSZip === 'undefined') {
              alert("JSZip library not loaded. Please try again or refresh.");
              console.error("JSZip library not found.");
              return;
          }

          const zip = new JSZip();
          savedGlyphOutputs.forEach((item) => {
            zip.file(item.filename, item.content);
          });

          try {
            const content = await zip.generateAsync({ type: "blob" });
            const url = URL.createObjectURL(content);
            const link = document.createElement("a");
            link.href = url;
            link.download = `dreamparser_glyph_exports_${Date.now()}.zip`;
            link.click();
            URL.revokeObjectURL(url);
            alert(`Exported ${savedGlyphOutputs.length} Glyphstream files.`);
          } catch (error) {
            console.error("Error generating Glyphstream zip:", error);
            alert("Failed to generate Glyphstream zip file.");
          }
        }, [savedGlyphOutputs]);

        // Optional: Clear All Saved Outputs
        const clearAllSavedOutputs = useCallback(() => {
            if (confirm("Are you sure you want to clear ALL saved outputs? This cannot be undone.")) {
                setSavedJsonOutputs([]);
                setSavedGlyphOutputs([]);
                localStorage.removeItem("dreamparser_saved_json");
                localStorage.removeItem("dreamparser_saved_glyph");
                alert("All saved outputs cleared.");
            }
        }, []);


        return (
          <div>
            <h1>DreamParserMAX</h1>
            <p>
              Enter your Virelle Glyphstream below to parse it into JSON, or
              paste JSON to convert it back to Virelle.
            </p>

            <div className="container">
              <div className="panel">
                <h2>Virelle Glyphstream → JSON</h2>
                <label htmlFor="glyphInput">
                  Paste Dreamstate Echoes, Narrative Lattices, or Core Units here:
                </label>
	<label htmlFor="glyphInput">
	Classify Core Units as needed Δ Ω Ψ Λ Θ ✵ ϟ χ ∑ ✦ ⊗ ✺ ∂ ⊕ φ ∞ ☷ ⚶
                </label>
	<label htmlFor="glyphInput">
	(Blank units default as ☲ “Spark” until assigned otherwise)
                </label>

                <textarea
                  id="glyphInput"
                  value={glyphInput}
                  onChange={(e) => setGlyphInput(e.target.value)}
                  placeholder="Paste your Virelle Glyphstream here..."
                  style={{ width: "100%", height: "250px" }}
                />
                <button onClick={handleParseGlyphstream}>Parse to JSON</button>

                <div className="output-area">
                  <label>JSON Output Format:</label>
                  <div className="radio-group">
                    <label>
                      <input
                        type="radio"
                        value="array"
                        checked={jsonOutputFormat === "array"}
                        onChange={(e) => setJsonOutputFormat(e.target.value)}
                      />
                      Array (list of constructs)
                    </label>
                    <label>
                      <input
                        type="radio"
                        value="object"
                        checked={jsonOutputFormat === "object"}
                        onChange={(e) => setJsonOutputFormat(e.target.value)}
                      />
                      Object (constructs by titleCore)
                    </label>
                  </div>
                  <label htmlFor="jsonOutputFilename">Output Filename (JSON):</label>
                  <input
                    id="jsonOutputFilename"
                    type="text"
                    placeholder="e.g., my_dream_log"
                    value={jsonOutputFilename}
                    onChange={(e) => setJsonOutputFilename(e.target.value)}
                  />
                  <button onClick={handleDownloadJson}>Download JSON</button>
                  <button onClick={saveCurrentJsonOutput} disabled={!jsonOutput}>Save Current JSON</button>
                  <button onClick={exportAllJsonOutputs} disabled={savedJsonOutputs.length === 0}>Export All Saved JSON ({savedJsonOutputs.length})</button>

                </div>
                <div className="output-area">
                  <pre id="jsonOutput">{jsonOutput}</pre>
                  {jsonOutput && (
                    <button
                      className="copy-button"
                      onClick={() => copyToClipboard(jsonOutput)}
                    >
                      Copy Output
                    </button>
                  )}
                </div>
              </div>

              <div className="panel">
                <h2>JSON → Virelle Glyphstream</h2>
                <label htmlFor="jsonInput">Paste your JSON here:</label>
                <textarea
                  id="jsonInput"
                  value={jsonInput}
                  onChange={(e) => setJsonInput(e.target.value)}
                  placeholder="Paste your JSON here..."
                  style={{ width: "100%", height: "250px" }}
                />
                <button onClick={emitGlyphstream}>Convert to Virelle</button>
                <div className="output-area">
                  <label htmlFor="glyphOutputFilename">Output Filename (Virelle):</label>
                  <input
                    id="glyphOutputFilename"
                    type="text"
                    placeholder="e.g., my_parsed_glyphstream"
                    value={glyphOutputFilename}
                    onChange={(e) => setGlyphOutputFilename(e.target.value)}
                  />
                  <button
                    onClick={handleDownloadGlyphstream}
                    disabled={!glyphOutput}
                  >
                    Download Virelle (.txt)
                  </button>
                  <button onClick={saveCurrentGlyphOutput} disabled={!glyphOutput}>Save Current Virelle</button>
                  <button onClick={exportAllGlyphOutputs} disabled={savedGlyphOutputs.length === 0}>Export All Saved Virelle ({savedGlyphOutputs.length})</button>

                </div>
                <div className="output-area">
                  <pre id="glyphOutput">{glyphOutput}</pre>
                  {glyphOutput && (
                    <button
                      className="copy-button"
                      onClick={() => copyToClipboard(glyphOutput)}
                    >
                      Copy Output
                    </button>
                  )}
                </div>
              </div>
            </div>
            <div style={{ marginTop: '2rem', textAlign: 'center' }}>
                <button onClick={clearAllSavedOutputs} disabled={savedJsonOutputs.length === 0 && savedGlyphOutputs.length === 0}>
                    Clear All Saved Outputs
                </button>
            </div>
          </div>
        );
      }

      ReactDOM.render(<DreamParser />, document.getElementById("root"));
    </script>
  </body>
</html>